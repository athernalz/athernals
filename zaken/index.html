<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zaken Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e;
            color: #e0e0e0;
        }
        .card {
            background-color: #162447;
            border: 1px solid #1f4068;
        }
        .btn-primary {
            background-color: #1f4068;
            transition: background-color: 0.3s ease;
        }
        .btn-primary:hover {
            background-color: #275288;
        }
        /* Custom style for checked player cards */
        .player-checkbox:checked + .player-card {
            border-color: #e43f5a;
            background-color: #1f4068;
        }
        .player-checkbox:checked + .player-card img {
            ring-width: 2px;
            ring-color: #e43f5a;
        }
        .radio-custom:checked {
            background-color: #e43f5a;
            border-color: #e43f5a;
        }
        .party-slot-icon {
            filter: drop-shadow(0 0 3px rgba(228, 63, 90, 0.7));
        }
        .btn-secondary {
            background-color: #2c3e50;
            border: 1px solid #34495e;
        }
        .btn-secondary:hover {
            background-color: #34495e;
        }
    </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">
    <div class="w-full max-w-6xl mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold text-white tracking-wider">
                Zaken Generator <span class="text-lg align-middle text-gray-500 font-medium">v2.0</span>
            </h1>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <!-- Controls Column -->
            <div class="lg:col-span-1 card rounded-lg p-6 shadow-lg">
                <div id="controls">
                    <!-- People Selection -->
                    <div>
                        <h2 class="text-xl font-semibold mb-3 border-b-2 border-gray-600 pb-2">1. Select Available People</h2>
                        <div id="player-list" class="grid grid-cols-3 gap-2 max-h-[30rem] overflow-y-auto pr-2">
                            <!-- Player cards will be injected here -->
                        </div>
                        <p class="mt-4 text-lg font-medium">Selected People: <span id="selected-count" class="font-bold text-white">0</span></p>
                    </div>

                    <!-- Run Selection -->
                    <div class="mt-6">
                        <h2 class="text-xl font-semibold mb-3 border-b-2 border-gray-600 pb-2">2. Select Number of Runs</h2>
                        <div class="flex items-center space-x-6">
                            <label class="flex items-center cursor-pointer">
                                <input type="radio" name="runs" value="1" class="radio-custom h-5 w-5 rounded-full border-gray-500 text-pink-500 focus:ring-pink-400" checked>
                                <span class="ml-2 text-lg">1 Run</span>
                            </label>
                            <label class="flex items-center cursor-pointer">
                                <input type="radio" name="runs" value="2" class="radio-custom h-5 w-5 rounded-full border-gray-500 text-pink-500 focus:ring-pink-400">
                                <span class="ml-2 text-lg">2 Runs</span>
                            </label>
                        </div>
                    </div>

                    <!-- Generate Button -->
                    <div class="mt-8">
                         <button id="generate-btn" class="w-full btn-primary text-white font-bold py-3 px-4 rounded-lg text-lg shadow-md hover:shadow-lg transform hover:-translate-y-0.5 transition-all duration-300">
                            Generate Party
                        </button>
                    </div>
                </div>
            </div>

            <!-- Results Column -->
            <div id="results-container" class="lg:col-span-2 space-y-6">
                 <!-- Placeholder -->
                <div id="placeholder" class="card rounded-lg p-8 h-full flex items-center justify-center text-center">
                    <div>
                        <svg class="mx-auto h-16 w-16 text-gray-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
                            <path vector-effect="non-scaling-stroke" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                        </svg>
                        <h3 class="mt-2 text-lg font-medium text-white">Your generated parties will appear here.</h3>
                        <p class="mt-1 text-gray-400">Select at least 9 people and click generate.</p>
                    </div>
                </div>
                <!-- Generated parties will be injected here -->
            </div>
        </main>
    </div>

<script>
        const playerData = [
            { name: 'Ahra', characters: [{ name: 'ahra', class: 'Bishop' }, { name: 'Vitina', class: 'Bishop' }, { name: 'Bobicu', class: 'DD' }, { name: 'MaDRabbit', class: 'DD', special: 'CW' }, { name: 'Thalik', class: 'DD', special: 'CW' }, { name: 'Axylia', class: 'SWS' }, { name: 'Romeow', class: 'COV' }] },
            { name: 'Axylia', characters: [{ name: 'Axylia', class: 'SWS' }, { name: 'Romeow', class: 'COV' }] },
            { name: 'Bobicu', characters: [{ name: 'Bobicu', class: 'DD', strength: 'high' }, { name: 'IWontHitYou', class: 'DD', shareGroup: 'A' }, { name: 'Axylia', class: 'SWS' }, { name: 'ahra', class: 'Bishop' }, { name: 'Vitina', class: 'Bishop' }, { name: 'MyDance', class: 'Recharger' }, { name: 'MyDance', class: 'BD' }] },
            { name: 'iKiku', characters: [{ name: 'iKiku', class: 'FI' }, { name: 'LaaLaa', class: 'SWS' }] },
            { name: 'IWillClapYou', characters: [{ name: 'IWillClapYou', class: 'Recharger' }, { name: 'IWontHitYou', class: 'DD', shareGroup: 'A' }, { name: 'MaDRabbit', class: 'DD', special: 'CW' }] },
            { name: 'MaDRabbit', characters: [{ name: 'MaDRabbit', class: 'DD', special: 'CW' }, { name: 'Romeow', class: 'COV' }] },
            { name: 'Pap1ll0n', characters: [{ name: 'Pap1ll0n', class: 'FI' }, { name: 'Vayek', class: 'JUDI' }, { name: 'Dreamhack', class: 'DD' }, { name: 'BlackKarou', class: 'DOD' }] },
            { name: 'Thalik', characters: [{ name: 'Thalik', class: 'DD', special: 'CW' }, { name: 'IWontHitYou', class: 'DD', shareGroup: 'A' }, { name: 'Romeow', class: 'COV' }] },
            { name: 'Zerathell', characters: [{ name: 'Zerathell', class: 'BD' }, { name: 'MyDance', class: 'BD' }] },
            { name: 'Dreamhack', characters: [{ name: 'Dreamhack', class: 'DD', strength: 'high' }, { name: 'Vayek', class: 'JUDI' }, { name: 'BlackKarou', class: 'DOD' }] },
            { name: 'Humax', characters: [{ name: 'iHumax', class: 'DD' }, { name: 'Xamuh', class: 'DD', shareGroup: 'A' }] },
            { name: 'MrA', characters: [{ name: 'MrA', class: 'Recharger' }, { name: 'Humax', class: 'COV' }, { name: 'iHumax', class: 'DD' }, { name: 'Xamuh', class: 'DD', shareGroup: 'A' }, { name: 'iKiku', class: 'FI' }] },
            { name: 'Galena', characters: [{ name: 'Vayek', class: 'JUDI' }, { name: 'BlackKarou', class: 'DOD' }, { name: 'Galena', class: 'Bishop' }] },
        ];
        
        const optionalRoles = ['DOD', 'JUDI'];

        const playerListContainer = document.getElementById('player-list');
        const selectedCountEl = document.getElementById('selected-count');
        const generateBtn = document.getElementById('generate-btn');
        const resultsContainer = document.getElementById('results-container');
        const placeholder = document.getElementById('placeholder');

        function initialize() {
            playerData.sort((a, b) => a.name.localeCompare(b.name));
            playerData.forEach(player => {
                const label = document.createElement('label');
                label.className = 'cursor-pointer';
                const playerNameLower = player.name.toLowerCase();
                label.innerHTML = `
                    <input type="checkbox" data-name="${player.name}" class="player-checkbox hidden">
                    <div class="player-card p-2 rounded-lg border-2 border-gray-700 bg-gray-800/50 hover:bg-gray-700/70 transition-all duration-200 flex flex-col items-center text-center h-full">
                        <img src="pfps/${playerNameLower}.png" alt="${player.name}" class="w-16 h-16 rounded-full object-cover mb-2 transition-all duration-200">
                        <span class="text-sm font-semibold">${player.name}</span>
                    </div>`;
                playerListContainer.appendChild(label);
            });
            playerListContainer.addEventListener('change', updateSelectedCount);
            generateBtn.addEventListener('click', handleGeneration);
        }

        function updateSelectedCount() {
            selectedCountEl.textContent = getSelectedPlayers().length;
        }

        function getSelectedPlayers() {
            return Array.from(document.querySelectorAll('.player-checkbox:checked')).map(cb => cb.dataset.name);
        }
        
        // NEW FUNCTION: To create balanced party cores for a 2-run setup
        function createBalancedInitialParties(characterPool) {
            const initialParty1 = {};
            const initialParty2 = {};
            const assignedPlayers = new Set();

            const assignToBalance = (char1, char2, role) => {
                if (char1 && !assignedPlayers.has(char1.player)) {
                    initialParty1[char1.player] = { role, char: char1 };
                    assignedPlayers.add(char1.player);
                }
                if (char2 && !assignedPlayers.has(char2.player)) {
                    initialParty2[char2.player] = { role, char: char2 };
                    assignedPlayers.add(char2.player);
                }
            };
            
            // Split CWs
            const cws = characterPool.filter(c => c.special === 'CW');
            if (cws.length >= 2) assignToBalance(cws[0], cws[1], 'DD');

            // Split high-strength DDs
            const strongDDs = characterPool.filter(c => c.strength === 'high' && !assignedPlayers.has(c.player));
            if (strongDDs.length >= 2) assignToBalance(strongDDs[0], strongDDs[1], 'DD');
            
            // Split essential support roles
            const supportRoles = ['Bishop', 'Recharger', 'COV', 'BD', 'SWS'];
            supportRoles.forEach(role => {
                const candidates = characterPool.filter(c => c.class === role && !assignedPlayers.has(c.player));
                const uniquePlayers = [...new Map(candidates.map(c => [c.player, c])).values()];
                if (uniquePlayers.length >= 2) {
                    assignToBalance(uniquePlayers[0], uniquePlayers[1], role);
                }
            });

            return { initialParty1, initialParty2 };
        }

        function handleGeneration() {
            const selectedPlayerNames = getSelectedPlayers();
            const numRuns = parseInt(document.querySelector('input[name="runs"]:checked').value, 10);

            if (selectedPlayerNames.length < 9) {
                renderError("Not enough people!", "You need to select at least 9 people to form a full party.");
                return;
            }

            const allAvailableChars = selectedPlayerNames.flatMap(name => {
                const player = playerData.find(p => p.name === name);
                return player.characters.map(char => {
                    const isHumaxMain = player.name === 'Humax' && char.name === 'iHumax';
                    const isStandardMain = player.name.toLowerCase() === char.name.toLowerCase();
                    return { player: player.name, isMain: isHumaxMain || isStandardMain, ...char };
                });
            });

            let run1 = null, run2 = null;

            if (numRuns === 2) {
                const { initialParty1 } = createBalancedInitialParties(allAvailableChars);
                
                run1 = findParty(allAvailableChars, selectedPlayerNames, initialParty1);
                
                if (run1) {
                    const usedPlayerNamesRun1 = Object.keys(run1.party);
                    const usedCharNamesRun1 = Object.values(run1.party).map(p => p.char.name);

                    // For run 2, we can use anyone not in run 1, plus anyone from run 1 on an alt
                    const remainingCharsForRun2 = allAvailableChars.filter(char => !usedCharNamesRun1.includes(char.name));
                    const playersForRun2 = [...new Set(remainingCharsForRun2.map(c => c.player))];
                    
                    run2 = findParty(remainingCharsForRun2, playersForRun2, {});
                }

            } else {
                run1 = findParty(allAvailableChars, selectedPlayerNames, {});
            }
            
            renderResults(run1, run2, allAvailableChars);
        }
        
        function findParty(characterPool, availablePlayerNames, initialParty = {}) {
            const party = { ...initialParty };
            
            // Derive initial state from the pre-filled party
            let cwCount = Object.values(party).filter(p => p.char.special === 'CW').length;
            let strongDdCount = Object.values(party).filter(p => p.char.strength === 'high').length;
            
            const supportRoles = ['Bishop', 'Recharger', 'COV', 'BD', 'SWS'];
            const neededSupportRoles = new Set(supportRoles);
            Object.values(party).forEach(p => {
                if (neededSupportRoles.has(p.role)) {
                    neededSupportRoles.delete(p.role);
                }
            });

            let neededDamageRoles = 4 - Object.values(party).filter(p => ['DD', 'FI'].includes(p.role)).length;


            const canAssign = (char) => {
                if (party[char.player] || Object.values(party).some(p => p.char.name === char.name)) return false;
                if (char.shareGroup && Object.values(party).some(p => p.char.shareGroup === char.shareGroup)) return false;
                return true;
            };
            
            const assign = (role, char) => {
                party[char.player] = { role, char };
                if (char.special === 'CW') cwCount++;
                if (char.strength === 'high') strongDdCount++;
            };
            
            // Pass 1: Prioritize assigning mains for required roles, starting with supports.
            const mainChars = characterPool.filter(c => c.isMain && canAssign(c));
            
            // 1a: Support Mains
            mainChars.filter(c => neededSupportRoles.has(c.class)).forEach(char => {
                if (canAssign(char) && neededSupportRoles.has(char.class)) {
                     assign(char.class, char);
                     neededSupportRoles.delete(char.class);
                }
            });
            // 1b: Damage Mains
            mainChars.filter(c => ['FI', 'DD'].includes(c.class)).forEach(char => {
                if (canAssign(char) && neededDamageRoles > 0) {
                     assign(char.class, char);
                     neededDamageRoles--;
                }
            });


            // Pass 2: Fill remaining essential support roles from alts.
            for (const role of [...neededSupportRoles]) {
                const candidates = characterPool.filter(c => c.class === role && canAssign(c));
                if (candidates.length > 0) {
                    assign(role, candidates[0]);
                    neededSupportRoles.delete(role);
                }
            }

            // Pass 3: Fill remaining damage roles from alts.
            if (neededDamageRoles > 0 && !Object.values(party).some(p => p.role === 'FI')) {
                const fiCandidates = characterPool.filter(c => c.class === 'FI' && canAssign(c));
                if (fiCandidates.length > 0) {
                    assign('FI', fiCandidates[0]);
                    neededDamageRoles--;
                }
            }
            
            while(neededDamageRoles > 0) {
                const ddCandidates = characterPool.filter(c => c.class === 'DD' && canAssign(c));
                if (ddCandidates.length === 0) break; 

                // Prioritize high strength, then CW, then regular
                ddCandidates.sort((a, b) => {
                    const scoreA = (a.strength === 'high' ? 10 : 0) + (a.special === 'CW' ? 5 : 0);
                    const scoreB = (b.strength === 'high' ? 10 : 0) + (b.special === 'CW' ? 5 : 0);
                    return scoreB - scoreA;
                });
                
                assign('DD', ddCandidates[0]);
                neededDamageRoles--;
            }

            // Pass 4: Try to add optional members
            const isFullParty = Object.keys(party).length >= 9 && neededSupportRoles.size === 0 && neededDamageRoles <= 0;
            if (isFullParty) {
                let optionalCandidate = null;
                if (Object.values(party).some(p=>p.role === 'Bishop')) {
                    optionalCandidate = characterPool.find(c => c.player === 'Galena' && optionalRoles.includes(c.class) && canAssign(c));
                }
                if (!optionalCandidate && Object.values(party).some(p=>p.role === 'FI')) {
                    optionalCandidate = characterPool.find(c => c.player === 'Pap1ll0n' && optionalRoles.includes(c.class) && canAssign(c));
                }
                if (!optionalCandidate) {
                    optionalCandidate = characterPool.find(c => optionalRoles.includes(c.class) && canAssign(c));
                }
                if (optionalCandidate) assign(optionalCandidate.class, optionalCandidate);
            }
            
            const filledSupports = Object.values(party).filter(p => supportRoles.includes(p.role));
            const filledDamage = Object.values(party).filter(p => ['DD', 'FI'].includes(p.role));
            const success = filledSupports.length === supportRoles.length && filledDamage.length >= 4;
            let missingRoles = [];

            if (!success) {
                supportRoles.forEach(role => {
                    if (!filledSupports.some(p => p.role === role)) missingRoles.push(role);
                });
                let neededDDs = 4 - filledDamage.length;
                if(neededDDs > 0 && !Object.values(party).some(p => p.role === 'FI')){
                    missingRoles.push('DD/FI');
                    neededDDs--;
                }
                for (let i = 0; i < neededDDs; i++) missingRoles.push('DD');
            }
            
            const assignedPlayerNames = Object.keys(party);
            const freePlayers = availablePlayerNames.filter(name => !assignedPlayerNames.includes(name));
            return { party, success, missingRoles, freePlayers };
        }
        
        function renderResults(run1, run2, allChars) {
            placeholder.classList.add('hidden');
            resultsContainer.innerHTML = '';
            
            let remainingForRun2 = allChars;
            if (run1) {
                const run1UsedChars = Object.values(run1.party).map(p => p.char.name);
                remainingForRun2 = allChars.filter(c => !run1UsedChars.includes(c.name));
                resultsContainer.appendChild(createPartyCard('Run 1', run1, allChars));
            }
            if (run2) {
                resultsContainer.appendChild(createPartyCard('Run 2', run2, remainingForRun2));
            }
        }
        
        function createPartyCard(title, runData, characterPool) {
            const card = document.createElement('div');
            card.className = 'card rounded-lg p-6 shadow-lg';
            card.innerHTML = `<h2 class="text-2xl font-bold mb-4 ${runData.success ? 'text-green-400' : 'text-red-400'}">${title} - ${runData.success ? 'Composition Found' : 'Failed to Form Party'}</h2>`;
            
            const grid = document.createElement('div');
            grid.className = 'grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4';
            const displayOrder = ['Bishop', 'Recharger', 'COV', 'BD', 'SWS', 'FI', 'DD', ...optionalRoles];
            const sortedParty = Object.values(runData.party).sort((a, b) => displayOrder.indexOf(a.role) - displayOrder.indexOf(b.role));

            sortedParty.forEach(({role, char}) => {
                const isOptional = optionalRoles.includes(role);
                const slotEl = document.createElement('div');
                slotEl.className = `p-3 rounded-lg flex items-center ${isOptional ? 'bg-indigo-900/40 border border-indigo-700' : 'bg-gray-800/50'}`;
                const playerNameLower = char.player.toLowerCase();
                slotEl.innerHTML = `
                    <div class="flex-shrink-0 h-10 w-10 rounded-full bg-gray-700 flex items-center justify-center overflow-hidden">
                       <img src="pfps/${playerNameLower}.png" alt="${char.player}" class="w-full h-full object-cover" onerror="this.outerHTML='<div class=\\'w-full h-full flex items-center justify-center font-bold text-pink-400 text-sm party-slot-icon\\'>${role}</div>'">
                    </div>
                    <div class="ml-3">
                        <p class="text-md font-semibold text-white">${char.player} ${char.isMain ? '<span class="text-xs text-yellow-400">(Main)</span>' : ''}</p>
                        <p class="text-sm text-gray-400">${char.class} (${char.name}) ${char.special === 'CW' ? '<span class="text-red-400 font-bold">(CW)</span>' : ''}</p>
                    </div>`;
                grid.appendChild(slotEl);
            });
            
            if (!runData.success && runData.missingRoles.length > 0) {
                runData.missingRoles.forEach(role => {
                    const slotEl = document.createElement('div');
                    slotEl.className = 'p-3 rounded-lg flex items-center bg-red-900/50 border border-red-700';
                    slotEl.innerHTML = `
                        <div class="flex-shrink-0 h-10 w-10 rounded-full bg-gray-700"></div>
                        <div class="ml-3">
                            <p class="text-md font-semibold text-red-300">MISSING</p>
                            <p class="text-sm text-red-400">${role}</p>
                        </div>`;
                    grid.appendChild(slotEl);
                });
            }
            card.appendChild(grid);
            
            const partyCharNames = Object.values(runData.party).map(p => p.char.name);

            const availableCharsSection = document.createElement('div');
            availableCharsSection.className = 'mt-6';
            
            if (characterPool.length > partyCharNames.length) {
                 availableCharsSection.innerHTML = `
                    <button class="show-available-btn btn-secondary text-white font-semibold py-2 px-4 rounded-md text-sm w-full">Show Available Characters</button>
                    <div class="available-chars-list hidden mt-4 p-4 bg-gray-900/50 rounded-lg max-h-48 overflow-y-auto"></div>
                `;
            }

            if (runData.freePlayers.length > 0) {
                const freePlayersEl = document.createElement('div');
                freePlayersEl.className = 'mt-4 pt-4 border-t border-gray-600';
                freePlayersEl.innerHTML = `
                    <h3 class="text-lg font-semibold text-cyan-400">Player(s) on Standby:</h3>
                    <p class="text-gray-300">${runData.freePlayers.join(', ')}</p>`;
                availableCharsSection.appendChild(freePlayersEl);
            }

            card.appendChild(availableCharsSection);

            const showBtn = card.querySelector('.show-available-btn');
            if (showBtn) {
                showBtn.addEventListener('click', (e) => {
                    const listContainer = e.target.nextElementSibling;
                    const isHidden = listContainer.classList.contains('hidden');
                    
                    if (isHidden) {
                        const availableForThisContext = characterPool.filter(c => !partyCharNames.includes(c.name));
                        const groupedByPlayer = availableForThisContext.reduce((acc, char) => {
                            if (!acc[char.player]) acc[char.player] = [];
                            acc[char.player].push(char);
                            return acc;
                        }, {});

                        let listHtml = '<ul class="space-y-2">';
                        for (const player in groupedByPlayer) {
                            const charsString = groupedByPlayer[player].map(c => `${c.name} (${c.class})`).join(', ');
                            listHtml += `<li><span class="font-bold text-white">${player}:</span> <span class="text-gray-300">${charsString}</span></li>`;
                        }
                        listHtml += '</ul>';

                        listContainer.innerHTML = listHtml;
                        listContainer.classList.remove('hidden');
                        e.target.textContent = 'Hide Available Characters';
                    } else {
                        listContainer.classList.add('hidden');
                        listContainer.innerHTML = '';
                        e.target.textContent = 'Show Available Characters';
                    }
                });
            }

            return card;
        }
        
        function renderError(title, message) {
            placeholder.classList.add('hidden');
            resultsContainer.innerHTML = '';
            const errorCard = document.createElement('div');
            errorCard.className = 'card rounded-lg p-8 text-center';
            errorCard.innerHTML = `
                 <svg class="mx-auto h-12 w-12 text-red-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                </svg>
                <h3 class="mt-4 text-2xl font-bold text-red-400">${title}</h3>
                <p class="mt-2 text-lg text-gray-300">${message}</p>`;
            resultsContainer.appendChild(errorCard);
        }

        document.addEventListener('DOMContentLoaded', initialize);
    </script>
</body>
</html>

