<script>
  let ws = null, reconnectTimer = null, backoff = 5000, maxBackoff = 60000;
  let sawAuthFailure = false;

  function send(line){ if(ws && ws.readyState===1){ ws.send(line + "\r\n"); } }

  function connect() {
    const channel = document.getElementById('chan').value.trim().replace(/^#/, '').toLowerCase();
    if (!channel) return;
    clearTimeout(reconnectTimer);
    if (ws) { try { ws.close(); } catch(_){} ws = null; }

    sawAuthFailure = false;
    document.getElementById('status').textContent = 'connecting…';

    const nick = 'justinfan' + Math.floor(Math.random()*1e6);
    ws = new WebSocket('wss://irc-ws.chat.twitch.tv:443');

    ws.onopen = () => {
      document.getElementById('status').textContent = 'auth…';
      // PASS can be any string for justinfan; Twitch ignores it
      send('PASS SCHMOOPIIE');
      send('NICK ' + nick);
      // Optional USER (not required by Twitch, but some proxies like it)
      send('USER ' + nick + ' 8 * :' + nick);
      // Ask for tags so we can read display-name
      send('CAP REQ :twitch.tv/tags twitch.tv/commands');

      // Small delay before JOIN; avoids immediate drops on some edges
      setTimeout(() => {
        send('JOIN #' + channel);
        document.getElementById('status').textContent = 'connected';
        document.getElementById('status').classList.add('ok');
        document.getElementById('status').classList.remove('warn');
        log('Connected as ' + nick + ' to #' + channel);
        backoff = 5000; // reset backoff on success
      }, 750);
    };

    ws.onmessage = (ev) => {
      // Log raw lines to see reasons coming from Twitch
      ev.data.split('\r\n').forEach(line => {
        if (!line) return;
        // Show control lines
        if (!line.includes('PRIVMSG')) log('IRC: ' + line);

        if (line.startsWith('PING')) {
          send('PONG :tmi.twitch.tv');
          return;
        }
        if (line.includes(' RECONNECT')) {
          log('Server asked to RECONNECT');
          try { ws.close(); } catch(_) {}
          return;
        }
        // auth failures / bans come as NOTICE
        if (line.includes(' NOTICE ') && /Login authentication failed|Error logging in/i.test(line)) {
          sawAuthFailure = true;
          log('Auth failed (Twitch said so). Anonymous might be blocked by something on your network.');
          try { ws.close(); } catch(_) {}
          return;
        }

        // Normal chat parsing
        let withoutTags = line.startsWith('@') ? line.slice(line.indexOf(' ')+1) : line;
        if (withoutTags.includes(' PRIVMSG ')) {
          const prefix = withoutTags.slice(1, withoutTags.indexOf(' '));
          const msgStart = withoutTags.indexOf(' :');
          const message = withoutTags.slice(msgStart+2);
          let user = 'user';
          const bang = prefix.indexOf('!');
          if (bang>1) user = prefix.slice(0, bang).replace(/^:/,'');
          if (line.startsWith('@')) {
            const tagStr = line.slice(1, line.indexOf(' '));
            const m = /display-name=([^;]*)/.exec(tagStr);
            if (m && m[1]) user = decodeURIComponent(m[1]);
          }
          onChat(user, message);
        }
      });
    };

    ws.onerror = () => {
      document.getElementById('status').textContent = 'error';
      document.getElementById('status').classList.add('warn');
      log('WS error (extension/VPN/firewall can cause this).');
    };

    ws.onclose = () => {
      document.getElementById('status').textContent = 'disconnected';
      document.getElementById('status').classList.add('warn');
      if (sawAuthFailure) { log('Not reconnecting due to auth failure.'); return; }
      log(`Disconnected. Reconnecting in ${Math.round(backoff/1000)}s…`);
      clearTimeout(reconnectTimer);
      reconnectTimer = setTimeout(connect, backoff);
      backoff = Math.min(backoff * 2, maxBackoff);
    };
  }

  document.getElementById('connect').onclick = connect;
  if (location.protocol !== 'file:') setTimeout(connect, 400);
</script>
